# Dynamic Programming
### What is Dynamic Programming?

### Procedure


### 좋은 문제들
#### 가장 긴/작은/큰 증가하는/감소하는 부분 수열
- 응용할 부분들이 꽤 있는 문제이다. 한번 쭉 정리할 필요가 있다

#### 11727
- 어려운 난이도는 아니다. 다만 나에게는 어려웠고, 답은 어거지로는 나오지만 정확히 증명하는 것은 살짝 난감했다. 개인적으로 DP문제들이 다들 그렇게 어렵지 않았는데, 이 친구는 DP의 정석같은 느낌이다. 간단히 경우를 더해보고, 케이스가 모두 충족되는지 확인하는 것만으로 점화식이 완성되는데, 일부러 답은 적지 않고, wrong_answers에 넣어놨다. 꼭꼭 다시 보자

#### **** 1010 다리놓기 ****
- silver5에 정답률도 낮지 않은 문제였다. 얻을 수 있는 것이 두가지가 있다.
- 다리를 이을 지점을 매치시키는 문제였다. 다리가 겹치지 않는 것이 포인트. 두가지 방법이 있다.
  1. combination을 이용하는 것. 일단, N,M이 30이하의 수라서 가능하다. ABC 중 두개의 알파벳으로 이루어진 조합은 AB AC BC로 3개이다. AB와 BA는 같은 것으로 취급하니 하나로 본다. 여기서 중요한 점은 combination에는 순서가 없으니, 각각의 케이스를 내 마음대로 조작할 수 있다는 것이다. 이를 테면 무조건 내림차순의 경우만 생각해야할 때, CAB는 옳지 않다. 하지만 combination은 순서가 없으니 CAB는 CBA와도 같고, 이를 내 임의로 내림차순으로 정리된 케이스로 생각할 수 있다는 것이다. !!겹치지 않는 무언가를 구해야할 때, combination의 이 성질을 잘 기억하자. 내 마음대로 순서 조작이 가능하다!!
  2. N, M을 적절히 작은 숫자로 지정 후 한 두가지 케이스를 살펴봤다. 중복되는 부분이 선명하게 보였고, Dynamic programming을 적용하면 효율적일 것으로 예상했다. 여기서 특별한 점은 2차원 DP를 만들었다는 것이다. N을 0, M을 M-N부터 시작하여 1씩 더해나가 보자. 규칙은 다음과 같았다.  
  ![Baekjoon_1010](./../image/Baekjoon_1010.jpeg)  
  현재 N을 j, M을 i라고 해보자. 새로 더해진 N, M쪽의 점들을 이어주면 그 때 모든 케이스들은 직전 케이스인 N=j-1, M=i-1과 경우의 수가 같다. M쪽에 새로 추가된 점을 N쪽에서 새로 추가된 점으로 이어준 케이스는 확인 했으니, 이제 M쪽에 새로 추가된 점이 어떤 점과도 이어지지 않는 케이스를 생각해보았다. 이는 N=j, M=i-1과 전혀 다를바 없는 경우이다. 우리는 N=M인 경우 1가지 case만 존재함을 알고 있다. 따라서 여기서부터 차근차근 DP를 채워나가면 중복되는 부분을 다시 계산하지 않고 답에 도달할 수 있다.

#### 9465
- 쉽다. 전형적인 쉬운 dp문제. 좋은 문제라기보단.. 걍 전형적인 문제라서 적어봤다

#### 12865
- 그 유명한 배낭 문제!

### Idea
#### 9095
- 일단 차례대로 전개해보며 규칙을 살펴보는 것도 좋다.

#### 9461
- 재귀함수와 for문 모두 구현해보는 식으로 연습하면 더 좋겠다.

#### 2294
- 전형적인 DP

### Python modules that i wasn't really familiar with
#### 1003
- 2차원 list * number을 했을 때 같은 주소를 갖는 list들이 복사될 뿐이다. a = [[0, 0] for _ in range(number)]로 해야한다!!!!

#### 2156
- 익숙한 형태의 문제라고해서 방심하지 말자. 조건을 꼼꼼히 따져보자. 하나의 다른 조건도 전혀 다른 로직을 요구할 수 있다.(당연한 말이긴 하다))